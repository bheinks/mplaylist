#!/usr/bin/env python3

# mplaylist - A simple MPlayer-compatible playlist generator.
# Version: 1.2
# Author: Brett Heinkel <bheinks@gmail.com>

import argparse
import os

from datetime import datetime
from random import shuffle
from re import split

def main():
    file_name = "playlist-" + datetime.now().strftime("%H%M%S")

    parser = argparse.ArgumentParser(
        description = "Generate a playlist of MPlayer-compatible media files.",
    )

    parser.add_argument(
        "files", metavar = "FILE",
        help = "valid MPlayer media file(s)",
        nargs = "*"
    )

    parser.add_argument(
        "-o", "--output",
        help = "specify output file name (defaults to \"playlist\" + current time)",
        action = "store",
        type = str
    )

    parser.add_argument(
        "-x", "--extensions",
        help = "limit playlist to certain file types (e.g. mplaylist ... -x avi,wma,mp4)",
        action = "store",
        type = str
    )

    parser.add_argument(
        "-r", "--random",
        help = "shuffle file names randomly",
        action = "store_true"
    )

    parser.add_argument(
        "-s", "--start",
        help = "specify the first index of the playlist",
        action = "store",
        type = int
    )

    parser.add_argument(
        "-e", "--end",
        help = "specify the last index of the playlist",
        action = "store",
        type = int
    )

    parser.add_argument(
        "-v", "--verbose",
        help = "output additional file information",
        action = "store_true"
    )

    args = parser.parse_args()

    global verbose
    verbose = args.verbose

    if args.files: # if file names passed as arguments
        files = args.files
    else: # else default to current working directory
        files = os.listdir()

    if args.extensions:
        extensions = args.extensions.split(',')
        files = [file for file in files if file.split('.')[-1] in extensions]
        
        if verbose: print("Limiting playlist to files of type:", ", ".join(extensions))

    # normalize start/end values as list indices
    if args.start:
        args.start -= 1 
    if args.end:
        args.end -= 1

    natural_sort(files) # sort playlist naturally

    if args.output: # if output file name specified
        file_name = args.output

    if args.random:
        if verbose: print("Shuffling files randomly...")

        # "backup"/remove index-sensitive values before shuffling
        if args.start: 
            start = files.pop(args.start)
        if args.end:
            end = files.pop(args.end)

        shuffle(files)

        if args.start: # reinsert specified start index at front
            files.insert(0, start)
        if args.end: # reappend specified end index at end
            files.append(end)
    else:
        # concatenate list with specified start/end indices
        if args.start:
            files = files[args.start:]
        if args.end:
            files = files[:args.end + 1]

    write_playlist(files, file_name)

# sort file names naturally (e.g. ["Ep. 1", "Ep. 2", "Ep. 10", "Ep. 11"])
def natural_sort(files):
    convert = lambda text: int(text) if text.isdigit() else text.lower() 
    alphanum = lambda key: [convert(char) for char in split('([0-9]+)', key)]

    files.sort(key = alphanum)

# write playlist file
def write_playlist(files, file_name):
    with open(file_name, "w") as playlist:
        if verbose: print("Writing to file:", file_name)

        for track in files:
            playlist.write(os.path.abspath(track) + '\n')

            if verbose: print('\t' + track)

if __name__ == "__main__":
    main()
